@@@@@@@Pointer
A pointer is a variable that stores the memory address of the variable.

@@@@@@@Declaration of pointer variable

Syntax : data_type *pname
Eg: int *ptr;

@@@@@@@Assigning address to pointer variable

Global and static pointers are automatically initialized to NULL but when we declare an automatic pointer variable it contains grabage value i.e. it may be pointing to any memory location.
Eg: int *ptr;
    age = 30;
    ptr = &age;
ptr contains the address of the variable age.

@@@@@@@Dereferencing pointer Variable

We can access a variable indirectly using the pointers.For this we will use the indirection operator (*).The indirection operator can be read as value at the address.
Eg: int a = 90;
    int *p1 = &a;
    *p1 = 9;
    Here a = 9
*(&a) also gives the value of a.
If a pointer that contains NULL is dereferenced, the results are implementation dependent.

We have already seen that while declaring a pointer variable, we have to mention the data type. The
reason is that when we use the indirection operator, the number of bytes retrieved will be different for
different data types. The value of the pointer only tells the address of starting byte. For example suppose
we have a pointer ptr which contains the address 2000 and when we write *ptr the compiler knows
that it has to access the information starting at address 2000. "So the compiler will look at the base
type of the pointer and will retrieve the information depending on that base type.For example if base
type is int then 2 bytes information will be retrieved and if base type is float, 4 bytes information will
be retrieved and so on.

@@@@@@@Pointer Aritmetic

Possible operations:
1. Addition of an integer to a pointer and increment operation.
2. Subtraction of an integer from a pointer and decrement operation.
3. Subtraction of a pointer from another pointer of same type.

Pointer arithmetic is somewhat different from ordinary arithmetic. Here all arithmetic is performed relative
to the size of base type of pointer. For example if we have an integer pointer pi which contains address
1000 then on incrementing we get 1002 instead of 1001. This is because the size of int data type is
2. Similarly on decrementing pi, we will get 998 instead of 999. The expression ( pi+3 ) will represent
the address 1006.

It is important to note that when we move a pointer somewhere else in memory by incrementing/
decrementing or adding/subtracting integers then it not necessary that the pointer still points to a variable
of same data type or a valid memory location. The task of allocating memory locations to variables
is done by the compiler. We don't know where and in what order it has stored them. We should take
care that we move the pointers in such a way that they always point to valid memory locations. In
case of arrays, elements are stored in consecutive order. So this arithmetic is generally applied in arrays.

The arithmetic operations that can never be performed on pointers are - Addition, multiplication, division of two pointers.
2. Multiplication between pointer and any number.
3. Division of a pointer by any number.
4. Addition of float or double values to pointers.

@@@@@@@Precedence Of Dereferencing Operator And /Increment/Decrement Operators

The precedence of * operator and increment/decrement operators, is same and their associativity
is from right to left.

Eg: x = *ptr++; -> is equivalent to *(ptr++).The increment operator is
postfix, so first the value of ptr will be used in the expression and then it will be incremented.
Hence first the integer pointed to ptr will be derefererced and assigned to x and then ptr wi1l be incremented. This is same as:
x = *ptr;
ptr = ptr+ 1; 

Suppose value at address 2000 is 25, value at address 2004 is 38, ptr is an integer pointer that contains address 2000, thus value
of *ptr is 25.

(i) x = *ptr++;
Value of x = 25, Address contained in ptr = 2004, *ptr = 38
(ii) x = *++ptr;
Value of x = 38, Address contained in ptr = 2004, *ptr = 38
(iii) x = ++*ptr;
Value of x= 26, Address contained in ptr = 2000, *ptr = 26
(iv) x = (*ptr)++;
Value of x = 25, Address contained in ptr = 2000, *ptr = 26

@@@@@@@Pointer Comparisons
The relational operators ==, != , < , <=, >, >= can be used with pointers. The operators == and != are used to compare two pointers for finding whether they contain same address or not. They will
be equal only if both are NULL or they contain address of same variable. The use of these operators
is valid between pointers of same type or between NULL pointer and any other pointer, or between
void pointer and any other pointer. The relational operators <, >; >=, <= are valid between pointers
of same type. These operations make sense only when both the pointers point to elements of the same
array.

@@@@@@@Pointer To pointer
We can store the address of a pointer variable in some other variable, which is known as a pointer to pointer variable.Pointer to pointer is generally used while passing pointer variables to functions.
The syntax of declaring a pointer to pointer is as:
data_type **pptr;

int a = 5;
int *pa = &a;
int **ppa = &pa;

@@@@@@@Pointers and One Dimensional Arrays
1. Elements of an array are stored in consecutive memory locations.
2. The name of an array is a constant pointer that points to the first element of the array, i.e. it stores
the address of the first element, also known as the base address of array. '"
3. According to pointer arithmetic, when a pointer variable is incremented, it points to the next location
of its base type.

@@@@@@@Subscripting Pointer Variables
Difference between the name of an array and a pointer variable is that the the name
of an array is a constant pointer and it will always point to the Oth element of the array. It is not
a variable, hence we cant assign some other address to it neither can we move it by incrementing
or decrementing.

arr[4];
arr = &num;      //Illegal
arr++; 		//Illegal
arr = arr -1;  //Illegal

int *ptr;
ptr = &num;        //Legal
ptr++; 		  //Legal
ptrr = ptrr -1;  //Legal

@@@@@@@Pointer to an Array
We can declare a pointer that can point to the whole array instead of only one element of array. This pointer is useful when talking about multidimensional arrays.
int (*ptr)[10];
One of the main applications of the array of pointers is to store multiple strings as an array of pointers to characters.
char* arr[5]
    = { "gfg", "geek", "Geek", "Geeks", "GeeksforGeeks" }

@@@@@@@Pointers And Two Dimensional Arrays
https://www.youtube.com/watch?v=3fOPOUnkcdQ

@@@@@@@Pointers and Functions
@@@@@@@Call by value
Call by Value:
In call by value, when a function is called, a copy of the actual parameter's value is passed to the formal parameter of the function. This means that changes made to the formal parameter inside the function do not affect the actual parameter outside the function. The following steps occur in call by value:

When the function is called, the value of the actual parameter is copied into the formal parameter.
Any modifications made to the formal parameter inside the function are confined to the function's scope and do not affect the original value of the actual parameter.

@@@@@@@Call by reference
In call by reference, the address of the actual parameter is passed to the formal parameter of the function. This allows the function to directly access and modify the value stored at that address. Any changes made to the formal parameter inside the function affect the actual parameter outside the function. The following steps occur in call by reference:

When the function is called, the address of the actual parameter is passed to the formal parameter.
The function can access the value stored at that address using pointer dereferencing and can modify it directly.
Modifications made to the formal parameter inside the function affect the value stored at the memory location of the actual parameter, thus affecting the original value outside the function

@@@@@@@returning more than one value from a functon
You can pass pointers as arguments to the function, and then the function can modify the values pointed to by these pointers. This allows you to effectively return multiple values.

@@@@@@@Function returning pointer
Syntax:
data_type *function_name(type1,type2..);
Eg:
float *fun(int,char);

@@@@@@@Passing 1-D array to a function
when an array is passed to a function, the changes made
inside the function affect the original array. This is because the function gets access to the original
array.
There are three ways of declaring the formal parameter, which has to
receive the array. We can declare it as an unsized or sized array or we can declare it as a pointer.
func(int a[])
{

}
func (int a [5] );
{

}
func (int *a);
{

}
In all the three cases the compiler reserves space only for a pointer variable inside the function. In the
function call, the array name is passed without any subscript or address operator. Since array name
represents the address of first element of array, hence this address is assigned to the pointer variable
in the function. So inside the function we have a pointer that contains the base address of the array.
In the above program, the argument a is declared as a pointer variable whose base type is int, and it
is initialized with the base address of array arr. We have studied that if we have a pointer variable containing , the base address of an array, then we can access any array element either by pointer notation or subscript notation. So inside the function, we can access any ith element of arr by writing *(a+i) or a[i]. Since we are directly accessing the original array hence all the changes made to the array in the called function are reflected in the calling function.

@@@@@@@void pointer
A pointer to void is a generic pointer that can point to any data type. The syntax of declaration of a void pointer is void *vpt;
Here void is a keyword and vpt is declared as a pointer of void type.
For example:
int i = 2, *ip = &i;
float f= 2.3, *fp = &f;
double d;
void *vp;

ip = fp; /*Incorrect */
vp = ip; /*Correct*/
vp = fp; /*Correct*/
vp = &d; /*Correct */
A void pointer can't be dereferenced simply by using indirection operator. Before dereferencing, it should
be type cast to appropriate pointer data type. For example if vp is a void pointer and it holds the address of an integer variable then we can't dereference it just by writing *vp. We'll have to write *(int *)vp, where leftmost asterisk is the indirection, operator and (int *) is used for typecasting. Similarly pointer arithmetic can't be performed on void pointers without typecasting.

@@@@@@@Dynamic Memory Allocation
Dynamic memory allocation is the process of assigning memory to a program during its execution rather than at compile time, allowing for flexible memory management.

Dynamic memory allocation involves allocating memory during program execution rather than at compile time. Memory is typically taken from a region called the heap. Functions like malloc, calloc, realloc, and free from libraries such as stdlib.h are used to manage dynamic memory. Pointers play a crucial role in accessing dynamically allocated memory because we can access the dynamically
allocated memory only through pointers.After use, memory should be deallocated using free to prevent memory leaks.

@@@@@@@Malloc
malloc() is a function in the C programming language that is used to dynamically allocate a specified number of bytes of memory during program execution, typically from the heap.

Syntax:
void* malloc(size_t size);
size is the number of bytes to allocate.

The return value of malloc() is a pointer to the beginning of the allocated memory block.The returned pointer is of type void, which can be type casted to appropriate type of pointer. If the allocation fails, it returns NULL.

ptr = (datatype *) malloc(specified size);
ptr = (int*)malloc(n * sizeof(int));

Here ptr is a pointer of type datatype, and specified size is the size in bytes required to be reserved memory. The expression (datatatype *) is used to typecast the pointer returned by malloc().
If there is not sufficient memory available in heap then malloc( ) returns NULL. So we should always
check the value returned by malloc( ).
ptr = (float *) malloc(lO*sizeof(float) );
if ( ptr = = NULL )
printf("Sufficient memory not available")

@@@@@@@Calloc
Declaration: void *calloc(size_t n, size_t size);

calloc() allocates multiple blocks of memory, similar to malloc(). It takes two arguments: 'n' specifying the number of blocks and 'size' specifying the size of each block.
Example:
ptr = (int*) calloc(5, sizeof(int));
This allocates 5 blocks of memory, each the size of an integer, and initializes them to zero. The starting address is stored in 'ptr'. 

An equivalent malloc() call requires manual calculation:
ptr = (int*) malloc(5 * sizeof(int));

Unlike malloc(), calloc() initializes memory to zero. However, this initialization may not always be reliable, so explicit initialization is recommended when necessary.
Both calloc() and malloc() return NULL if there is insufficient memory available in the heap.


@@@@@@@realloc()
Declaration: void *realloc(void *ptr, size_t newsize)

realloc() is used to resize memory allocated by malloc() or calloc() without losing existing data. It takes a pointer to the previously allocated memory block and the new size as arguments.

Example:
ptr = (int *) malloc(size);
This allocates memory of 'size' bytes, storing the starting address in 'ptr'. To resize the memory block, use:

ptr = (int *) realloc(ptr, newsize);
This statement allocates the memory space of newsize bytes, and the starting address of this memory block is stored in the pointer variable ptr. If 'newsize' is larger, old data is retained, and new memory is uninitialized. 'ptr' may change if insufficient memory exists at the old address to hold all bytes consecutively.This function moves the contents of the old block into the new block and the data of the old d block is not lost. On failure, realloc() returns NULL.

@@@@@@@free()
Dynamically allocated memory isn't automatically released. It's our responsibility to free it using the free() function once we're done with it. For example:
free(ptr);
Attempting to free memory not allocated by malloc(), calloc(), or realloc() results in undefined behavior. Although the operating system automatically releases memory when the program terminates, it's a good practice to free dynamically allocated memory to prevent memory leaks.

@@@@@@@Pointers To Functions
We can get the address of a function by just writing the function's name without parantheses.

Syntax:
return_type (*pointer_name)(parameter_type1, parameter_type2, ...);

Eg:
char (*func_p)(float, char);
float (*fp)( int );

Here fp is a pointer that can point to any function returning a float value and accepting an int argument. Similarly, func_p is a pointer that can point to functions returning char and accepting float and char as arguments.

We can see that this declaration is somewhat similar to the declaration of a function, except that the pointer name is preceded by a * and is enclosed in parentheses. The use of * is obvious since we did this while declaring pointers to variables also, but why is the pointer name enclosed in parentheses? Let us remove the parentheses and see.

float *fp(int);

How would you declare a function returning a pointer to float and taking an int value? Well, exactly in the same manner as above. So in this declaration fp is declared to be a function rather than a pointer, and this happened because parentheses have higher precedence than the * operator. This is the reason for enclosing the pointer name inside parentheses.

float *fp(int);
fp = func;
The above assignment fp contains the address of function func().

r = func( a, b); /*Calling function in usual way*/
r = (*fp)(a; b); /*Calling function via function pointer */

Function pointers are generally used in compilers, interpreters and database programs.

@@@@@@@Here is a review of the pointer declarations used in this chapter:

int *p; /*Pointer to int */
int **p; /*Pointer to pointer to int */
int *p[20]; /* Array of 20 int pointers*/
int (*p)[20]; /* Pointer to an array of 20 integers */
int *f(void); /*Function that returns an int pointer*/

int (*fp)(void); /*Pointer to a function, function returns int */
int (*fp[4] )(void); /*An array of 4 pointers to functions, each function returns int*/
int *(*fp)(void); /*Pointer to a function, function returns an int pointer */
float *(*fp)(int, float); /*Pointer to a function, function takes two arguments of int and float type and returns a float pointer*/
float *(*fp[4] )(int, float); /*An array of 4 pointers to functions, each function takes two arguments of int and float type and returns a float pointer*/







@@@@@@@Notes
int *ptr[10] and int (*ptr)[10] are both declarations involving pointers in C, but they have different meanings.

int *ptr[10]:

This declares an array of 10 pointers to integers.
Each element of the array ptr is a pointer to an integer.
It can be visualized as an array of pointers, where each pointer can point to a different integer or an array of integers.

int (*ptr)[10]:

This declares a pointer to an array of 10 integers.
It is a single pointer that can point to an entire array of integers (in this case, an array of size 10).
It can be visualized as a single pointer pointing to the beginning of an array of integers.
Here's a comparison of the two:

#include <stdio.h>

int main() {
    int x = 5;
    int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

    // int *ptr[10] - Array of pointers to integers
    int *ptr_to_integers[10];

    // Assigning the address of an integer to each element of the array of pointers
    for (int i = 0; i < 10; i++) {
        ptr_to_integers[i] = &x;
    }

    // Accessing the elements through the array of pointers
    printf("Using array of pointers to integers:\n");
    for (int i = 0; i < 10; i++) {
        printf("%d ", *ptr_to_integers[i]);
    }
    printf("\n");

    // int (*ptr)[10] - Pointer to an array of integers
    int (*ptr_to_array)[10];

    // Assigning the address of an array to the pointer
    ptr_to_array = &arr;

    // Accessing the elements through the pointer to the array
    printf("\nUsing pointer to array of integers:\n");
    for (int i = 0; i < 10; i++) {
        printf("%d ", (*ptr_to_array)[i]);
    }
    printf("\n");

    return 0;
}

Output:

Using array of pointers to integers:
5 5 5 5 5 5 5 5 5 5 

Using pointer to array of integers:
1 2 3 4 5 6 7 8 9 10 
In this example, ptr_to_integers is an array of pointers to integers, while ptr_to_array is a pointer to an array of integers. The output demonstrates accessing elements using these two different pointer types.






